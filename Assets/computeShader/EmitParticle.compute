// Each #kernel tells which function to compile; you can have many kernels
#include "particle.h"
#include "mathLib.h"


#pragma kernel EmitParticle


RWStructuredBuffer<EmitParticleInfo> emitParticleInfo;
RWStructuredBuffer<Particle> particlePool;
RWStructuredBuffer<ParticleCounter> particleCounter;

AppendStructuredBuffer<uint> alivelist;
ConsumeStructuredBuffer<uint> deadlist;

float time;

float rand(float2 co, float offset) {
	co += float2(offset, offset);

	return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

float randNP1(float2 co, float offset) {
	return rand(co, offset) * 2.0 - 1.0;
}

void SetSubframe(uint index, uint3 id) {
	float t = id.x / float(emitParticleInfo[0].realEmitCount);
	particlePool[index].lifespan = t * emitParticleInfo[0]._dt;
	particlePool[index].position -= t * (emitParticleInfo[0].originPos - emitParticleInfo[0].prevPosition);
}

void SetDefaultScale(uint index, float2 randKey) {
	particlePool[index].scale = (randNP1(randKey, 0.0) * emitParticleInfo[0].scaleRandom + 1.0)  * emitParticleInfo[0].scale;
}


void boxEmit(uint index, uint3 id) {
	float2 randKey = float2(index, time);
	float3 posOffset = float3(randNP1(randKey, 0.0), randNP1(randKey, 1.0), randNP1(randKey, 2.0)) * emitParticleInfo[0].boxEmitSize;
	particlePool[index].velocity = emitParticleInfo[0].startVelocity * AxisRotateByQuaternion(float3(0.0, 0.0, 1.0), emitParticleInfo[0].emitterRot);
	particlePool[index].quaternion = Quaternion(); //emitParticleInfo[0].rotation;
	particlePool[index].position = emitParticleInfo[0].originPos + posOffset;
	SetDefaultScale(index, randKey);
	SetSubframe(index, id);	
	
}

void coneEmit(uint index, uint3 id) {
	float2 randKey = float2(index/1024.0*time, time);
	float randAngle = rand(randKey, 2.0) * (emitParticleInfo[0].coneEmitAngle * 0.5);
	float3 revX = AxisRotateByQuaternion(float3(1.0, 0.0, 0.0), emitParticleInfo[0].emitterRot);
	float3 revY = AxisRotateByQuaternion(float3(0.0, 1.0, 0.0), emitParticleInfo[0].emitterRot);
	float3 revZ = AxisRotateByQuaternion(float3(0.0, 0.0, 1.0), emitParticleInfo[0].emitterRot);
	float4 rot = NormalizeQuaternion(Quaternion( normalize(revX * randNP1(randKey, 0.0) + revY * randNP1(randKey, 1.0)), randAngle));
	float3 dir = normalize(AxisRotateByQuaternion(revZ, rot));
	particlePool[index].velocity = emitParticleInfo[0].startVelocity * dir;
	particlePool[index].quaternion = Quaternion();// emitParticleInfo[0].rotation;
	particlePool[index].position = emitParticleInfo[0].originPos;
	SetDefaultScale(index, randKey);
	SetSubframe(index, id);	
}

void sphereEmit(uint index, uint3 id) {
	float2 randKey = float2(index, time);
	float3 dir = normalize(float3(randNP1(randKey, 0.0), randNP1(randKey, 1.0), randNP1(randKey, 2.0)));
	particlePool[index].velocity = emitParticleInfo[0].startVelocity * dir;
	particlePool[index].quaternion = Quaternion();// emitParticleInfo[0].rotation;
	particlePool[index].position = emitParticleInfo[0].originPos + dir * emitParticleInfo[0].radius;
	SetDefaultScale(index, randKey);
	SetSubframe(index, id);
}

void InitParticle(uint index, uint3 id) {
	[call]switch(emitParticleInfo[0].emitKind) {
    case 1:
    	sphereEmit(index, id);
        break;
    case 2:
    	coneEmit(index, id);
        break;
    case 3:
    	boxEmit(index, id);
        break;
	}
}

[numthreads(1024,1,1)]
void EmitParticle (uint3 id : SV_DispatchThreadID)
{
  if (id.x < emitParticleInfo[0].realEmitCount) {
	uint particleId = deadlist.Consume();
	alivelist.Append(particleId);
	InitParticle(particleId, id);

	InterlockedAdd(particleCounter[0].deadlistCount, -1);
	InterlockedAdd(particleCounter[0].alivelistCount, 1);

  }
}
