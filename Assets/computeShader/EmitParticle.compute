// Each #kernel tells which function to compile; you can have many kernels
#include "particle.h"
#include "mathLib.h"


#pragma kernel EmitParticle


RWStructuredBuffer<EmitParticleInfo> emitParticleInfo;
RWStructuredBuffer<Particle> particlePool;
RWStructuredBuffer<ParticleCounter> particleCounter;

AppendStructuredBuffer<uint> alivelist;
ConsumeStructuredBuffer<uint> deadlist;


float rand(float2 co, float offset) {
	co += float2(offset, offset);

	return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

float randNP1(float2 co, float offset) {
	return rand(co, offset) * 2 - 1;
}

float3 GenVolumePosition(float3 originPos, float radius, float3 id) {


	return originPos + float3(radius * rand(id.xy, 0.0), radius * rand(id.xy, 1.0), radius * rand(id.xy, 2.0));
}

void SetSubframe(uint index, uint3 id) {
	float t = id.x / float(emitParticleInfo[0].realEmitCount);
	particlePool[index].lifespan = t * emitParticleInfo[0]._dt;
	particlePool[index].position -= t * (emitParticleInfo[0].originPos - emitParticleInfo[0].prevPosition);
}

void SetDefaultScale(uint index, float2 randKey) {
	particlePool[index].scale = (randNP1(randKey, 0.0) * emitParticleInfo[0].scaleRandom + 1.0)  * emitParticleInfo[0].scale;
}


void boxEmit(uint index, uint3 id) {
	float2 randKey = float2(index, id.x);
	float3 posOffset = float3(randNP1(randKey, 0.0), randNP1(randKey, 1.0), randNP1(randKey, 2.0)) * emitParticleInfo[0].boxEmitSize;
	particlePool[index].velocity = emitParticleInfo[0].startVelocity * emitParticleInfo[0].forwardDir;
	particlePool[index].quaternion = emitParticleInfo[0].rotation;
	particlePool[index].position = emitParticleInfo[0].originPos + posOffset;
	SetDefaultScale(index, randKey);
	SetSubframe(index, id);	
	
}

void coneEmit(uint index, uint3 id) {
	float2 randKey = float2(index, id.x/1024.0);
	float randAngle = rand(randKey, 2.0) * emitParticleInfo[0].coneEmitAngle;
	float4 rot = Quaternion( normalize(float3(randNP1(randKey, 0.0), randNP1(randKey, 1.0), 0.0)), randAngle);
	float3 dir = rotate_vector(emitParticleInfo[0].forwardDir, rot);
	particlePool[index].velocity = emitParticleInfo[0].startVelocity * dir;
	particlePool[index].quaternion = emitParticleInfo[0].rotation;
	particlePool[index].position = emitParticleInfo[0].originPos;
	SetDefaultScale(index, randKey);
	SetSubframe(index, id);	
}

void sphereEmit(uint index, uint3 id) {
	float2 randKey = float2(index, id.x);
	float3 dir = normalize(float3(randNP1(randKey, 0.0), randNP1(randKey, 1.0), randNP1(randKey, 2.0)));
	particlePool[index].velocity = emitParticleInfo[0].startVelocity * dir;
	particlePool[index].quaternion = emitParticleInfo[0].rotation;
	particlePool[index].position = emitParticleInfo[0].originPos;
	SetDefaultScale(index, randKey);
	SetSubframe(index, id);
}

void InitParticle(uint index, uint3 id) {
  float2 uv = float2(index, id.x);
  float t = id.x / float(emitParticleInfo[0].realEmitCount);
  //float4 rot = emitParticleInfo[0].rotation;
  particlePool[index].scale = (randNP1(uv, 0.0) * emitParticleInfo[0].scaleRandom + 1.0)  * emitParticleInfo[0].scale;
  particlePool[index].lifespan = t * emitParticleInfo[0]._dt;
  particlePool[index].quaternion = Quaternion();
  particlePool[index].position = GenVolumePosition(emitParticleInfo[0].originPos - t * (emitParticleInfo[0].originPos - emitParticleInfo[0].prevPosition), emitParticleInfo[0].radius, float3(index, index, 0.0));
  particlePool[index].velocity = emitParticleInfo[0].startVelocity * emitParticleInfo[0].forwardDir * float3(randNP1(uv, 0.0), randNP1(uv, 1.0), randNP1(uv, 2.0));
}

[numthreads(1024,1,1)]
void EmitParticle (uint3 id : SV_DispatchThreadID)
{
  if (id.x < emitParticleInfo[0].realEmitCount) {
	uint particleId = deadlist.Consume();
	alivelist.Append(particleId);
	//InitParticle(particleId, id);
	//sphereEmit(particleId, id);
	//coneEmit(particleId, id);
	boxEmit(particleId, id);

	InterlockedAdd(particleCounter[0].deadlistCount, -1);
	InterlockedAdd(particleCounter[0].alivelistCount, 1);

  }
}
